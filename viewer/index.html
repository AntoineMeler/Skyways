<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Point Cloud Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: "Helvetica Neue";}
    canvas { display: block; }
    .loader {
        width: 48px;
        height: 48px;
        border: 5px solid #FFF;
        border-bottom-color: transparent;
        border-radius: 50%;
        display: inline-block;
        box-sizing: border-box;
        animation: rotation 1s linear infinite;
        }

        @keyframes rotation {
        0% {
            transform: rotate(0deg);
        }
        100% {
            transform: rotate(360deg);
        }
    } 
  </style>
</head>
<body>
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/PLYLoader.js"></script>
<script>

// Scene setup
const scene = new THREE.Scene();

lines_group = new THREE.Group();
points_group = new THREE.Group();
scene.add(lines_group);
scene.add(points_group);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const center = new THREE.Vector3(-30, -50, 20);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Orbit Controls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.copy(center);
camera.position.set(center.x, center.y - 40, 75);
controls.minDistance =   1; // Minimum zoom
controls.maxDistance = 200; // Maximum zoom
controls.update();

//=========================================================================
// light
//=========================================================================

const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Soft white light
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.95);
directionalLight.position.set(10, 10, 40); // Simulates sunlight
directionalLight.castShadow = true;
scene.add(directionalLight);

//=========================================================================
// Load heightmap
//=========================================================================

const loader = new THREE.TextureLoader();
loader.load('heightmap.png', (texture) => {
loader.load('colormap.jpg', (colorTexture) => {
    
    // Access the image data from the texture
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = texture.image.width;
    canvas.height = texture.image.height;
    context.drawImage(texture.image, 0, 0);
    const pixels = context.getImageData(0, 0, canvas.width, canvas.height).data;

    // Modify the geometry vertices based on the heightmap
    const planeGeometry = new THREE.PlaneGeometry(256, 256, texture.image.width-1, texture.image.height-1);
    const vertices = planeGeometry.attributes.position.array;
    const width = canvas.width;

    for (let i = 0; i < vertices.length/3; i++)
    {
        const x = i % width;
        const y = Math.floor(i / width);
        const pixelIndex = (y * width + x) * 4;
        const height = pixels[pixelIndex] / 255;
        vertices[i * 3 + 2] = height * 40; // Scale height by displacement scale
    }

    // Update the geometry and normals
    planeGeometry.attributes.position.needsUpdate = true;
    planeGeometry.computeVertexNormals();

    const planeMaterial = new THREE.MeshPhongMaterial(
    {
        //color : 0xFFFFFF,
        map: colorTexture, // color texture
        side: THREE.DoubleSide
    });
    const mesh = new THREE.Mesh(planeGeometry, planeMaterial);
    scene.add(mesh);
})
});

//=========================================================================
// Load PLY file
//=========================================================================

const loadPLYFile = (url) =>
{
    fetch(url)
    .then(response => {
        if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);
        return response.arrayBuffer();
    })
    .then(data => {
        points_group.clear();

        const loader = new THREE.PLYLoader();
        const geometry = loader.parse(data);
        geometry.computeBoundingBox();

        // Material and points
        const material = new THREE.PointsMaterial({ size: 0.02, vertexColors: true });
        const points = new THREE.Points(geometry, material);
        points_group.add(points);
        
        data_loaded();
    })
    .catch(error => {
        console.error('Error loading PLY file:', error);
    });
};

function loadPoints()
{
    const path = '/results/last.ply';
    loadPLYFile(path);
}

//=========================================================================
// lines
//=========================================================================

function loadLines()
{
    const path = '/results/last.json';
    fetch(path).then(response => response.json()).then(data =>
    {
        lines_group.clear();

        for (var line of data)
        {
            if (line.type == 0)
            {
                const material = new THREE.PointsMaterial({size: 0.3, vertexColors: true});
                const nb_colors = line.colors.length;

                var colors = [];
                var points = [];
                for (var pt in line.points)
                {
                    points.push(line.points[pt][0],
                                line.points[pt][1],
                                line.points[pt][2]);
                    colors.push(line.colors[Math.min(nb_colors-1, pt)][0],
                                line.colors[Math.min(nb_colors-1, pt)][1],
                                line.colors[Math.min(nb_colors-1, pt)][2]);
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
                geometry.setAttribute('color',    new THREE.Float32BufferAttribute(colors, 3));
                //lines_group.add(new THREE.Points(geometry, material));
            }
            else if (line.type == 1)
            {
                const material = new THREE.LineBasicMaterial({color: new THREE.Color().setRGB(line.color[0], line.color[1], line.color[2])});
                var points = [];
                for (var pt of line.points)
                    points.push(new THREE.Vector3(pt[0], pt[1], pt[2]));
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                lines_group.add(new THREE.Line(geometry, material));
            }
            else if (line.type == 2) // sphere
            {
                const geometry = new THREE.SphereGeometry(line.radius, 32, 16);
                var color = {color: new THREE.Color().setRGB(line.color[0], line.color[1], line.color[2])};
                if (line.opacity != undefined && line.opacity < 1.)
                {
                    color.transparent = true;
                    color.opacity = line.opacity;
                }
                const material = new THREE.MeshBasicMaterial(color);
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(line.position[0], line.position[1], line.position[2]);
                lines_group.add(sphere);
            }
        }
        data_loaded();
    });
}

//=========================================================================
//
//=========================================================================

// Render loop
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}
animate();

// Resize handler
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});


// Keyboard movement speed
const moveSpeed = 4.0;

window.addEventListener('keydown', (event) => {
    let offset = new THREE.Vector3();

    switch (event.key) {
        case "ArrowUp":
            offset.set(0, moveSpeed, 0);
            break;
        case "ArrowDown":
            offset.set(0, -moveSpeed, 0);
            break;
        case "ArrowLeft":
            offset.set(-moveSpeed, 0, 0);
            break;
        case "ArrowRight":
            offset.set(moveSpeed, 0, 0);
            break;
        default:
            return
    }

    camera.position.add(offset);
    controls.target.add(offset);
    controls.update();
});

</script>



<div style="position:absolute; top:10px; left:10px; color:#fff">
<input type="checkbox" onchange="points_group.visible = this.checked" checked> show points <span style="cursor:pointer" onclick="reload_data(true, false)">⟳</span><br>
<input type="checkbox" onchange="lines_group.visible = this.checked" checked> show lines <span style="cursor:pointer" onclick="reload_data(false, true)">⟳</span><br>
</div>

<div id="spinner" style="position:absolute; top:10px; right:10px;"><span class="loader"></span></div>



<script>
var nb_data_to_load = 0;

function data_loaded()
{
    nb_data_to_load--;
    if (nb_data_to_load == 0)
        document.getElementById("spinner").style.display = "none";
}

function reload_data(points, lines)
{
    nb_data_to_load = (points ? 1 : 0) + (lines ? 1 : 0);
    document.getElementById("spinner").style.display = "block";
    if (lines)
        loadLines();
    if (points)
        loadPoints();
}

reload_data(true, true);

</script>
</body>
</html>